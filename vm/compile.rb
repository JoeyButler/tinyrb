# Compile a Ruby script to an embedable C header file containing an array
# of instruction sequences generated by YARV.
# Usage:
# 
#  ruby19 compile.rb boot.rb > boot.c
#
# Then include in your C code:
#
#  #include "boot.h"

raise "Ruby 1.9 required" unless RUBY_VERSION =~ /1\.9/

# Stolen from HotRuby: http://hotruby.accelart.jp/js/HotRuby.js
OUTPUT_COMPILE_OPTION = {
  :peephole_optimization    => true,
  :inline_const_cache       => false,
  :specialized_instruction  => false,
  :operands_unification     => false,
  :instructions_unification => false,
  :stack_caching            => false,
}

iseq = VM::InstructionSequence.compile_file(ARGV.first, OUTPUT_COMPILE_OPTION)

# iseq.to_a.each do |i|
#   puts i.inspect
# end
# exit

class InstructionConverter
  def initialize(name, iseq, &block)
    @name       = name
    @iseq       = iseq
    @out        = []
    @converters = {}
    @line       = 0
    @blocks     = []
    
    # TODO remove, put back to putobject
    # special convertions
    convert :putobject do |cmds|
      type = case cmds[0]
      when Fixnum
        op :putfixnum, cmds[0]
      when Symbol
        op :putsymbol, cmds[0]
      else
        op :putspecial, cmds[0]
      end
    end
  end
  
  def convert(code, &block)
    @converters[code] = block
  end
  
  def op(code, *cmds)
    cmd = cmds.collect { |c| convert_type(code, c) }
    code_fix = "tr_fixnum_new(vm, #{code.to_s.upcase})"
    @out << %Q[  tr_array_push(vm, o, tr_array_create(vm, #{2+cmd.size}, tr_fixnum_new(vm, #{@line}), #{[code_fix, *cmd].join(", ")}));]
  end
  
  def convert_type(code, v)
    case v
    when Symbol
      "tr_intern(vm, \"#{v}\")"
    when NilClass
      "TR_NIL"
    when TrueClass
      "TR_TRUE"
    when FalseClass
      "TR_FALSE"
    when String
      v[0..2] == "TR_" ? v : "tr_string_new(vm, #{v.inspect})"
    when Fixnum
      "tr_fixnum_new(vm, #{v})"
    when Array
      if code == :duparray
        "tr_array_create(vm, #{v.size}, #{v.map { |i| convert_type(code, i) }.join(", ")})"
      else
        key = "#{@name}_b#{@blocks.size+1}"
        @blocks << InstructionConverter.new(key, v).to_s
        key + "(vm)"
      end
    else
      v.inspect
    end
  end
  
  def run
    @iseq.to_a.last.each do |inst|
      case inst
      when Fixnum # line number
        @line = inst
      when Symbol # label
        op :label, inst
      else
        if c = @converters[inst[0]]
          c.call(inst[1..-1])
        else
          op inst[0], *inst[1..-1]
        end
      end
    end
  end
  
  def to_s
    run
    @blocks.join("\n") <<
    "\n" <<
    "OBJ #{@name}(VM)\n{\n" <<
    "  OBJ o = tr_array_new(vm);\n" <<
    @out.join("\n") << "\n" <<
    "  return o;\n" <<
    "}"
  end
end

puts '#include "tinyrb.h"'
puts
puts InstructionConverter.new("tr_boot", iseq).to_s
puts